{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE OverloadedStrings #-}

module Elasticsearch where

import Control.Monad               (sequence_, unless)
import Control.Monad.Reader        (MonadIO, MonadReader, asks)
import Data.Aeson
import Database.V5.Bloodhound
import GHC.Generics                (Generic)
import Database.Persist.Postgresql (Entity(..), selectList, fromSqlKey)
import Network.HTTP.Client         (responseStatus)
import Network.HTTP.Types          (statusCode)
import qualified Data.Text         as T

import Models                      ($moduleName(..), runDb)
import Config                      (Config, esEnv)

data ${moduleName}Mapping = ${moduleName}Mapping deriving (Eq, Show, Generic)

instance FromJSON ${moduleName}Mapping 
instance ToJSON  ${moduleName}Mapping

indexSettings :: IndexSettings
indexSettings = defaultIndexSettings

indexName :: IndexName
indexName = IndexName "yourindex"

mappingName :: MappingName
mappingName = MappingName "yourmapping"

makeIndex :: (MonadReader Config m, MonadIO m) => m Reply
makeIndex = runES $$ createIndex indexSettings indexName

destroyIndex :: (MonadReader Config m, MonadIO m) => m Reply
destroyIndex = runES $$ deleteIndex indexName

makeMapping :: (MonadReader Config m, MonadIO m) => m Reply
makeMapping = runES $$ putMapping indexName mappingName ${moduleName}Mapping 

put${moduleName} :: (MonadReader Config m, MonadIO m) => $moduleName -> T.Text -> m Reply
put${moduleName} object dID = do
    reply <- get${moduleName} dID
    let sCode = statusCode $$ responseStatus reply
    case sCode of
      -- update
      200 -> update${moduleName} object dID
      -- create
      404 -> runES $$ 
             indexDocument 
             indexName 
             mappingName 
             defaultIndexDocumentSettings 
             object $$ DocId dID

update${moduleName} :: (MonadReader Config m, MonadIO m) => Registration -> T.Text -> m Reply
update${moduleName} object dID = runES $$ 
                               updateDocument 
                               indexName 
                               mappingName 
                               defaultIndexDocumentSettings 
                               object $$ DocId dID

all${moduleName}s :: (MonadReader Config m, MonadIO m) => m [Entity $moduleName]
all${moduleName}s = runDb $$ selectList []Â []

syncDb${moduleName}s :: (MonadReader Config m, MonadIO m) => m [Reply]
syncDb${moduleName}s = do
    exists <- runES $$ indexExists indexName
    unless exists $$ sequence_ [makeIndex, makeMapping]
    objects <- all${moduleName}s
    mapped <- mapM (\x -> put${moduleName} (entityVal x) (getRegId x)) objects
    return mapped

get${moduleName} :: (MonadReader Config m, MonadIO m) => T.Text -> m Reply
get${moduleName} dID = runES $$ getDocument indexName mappingName (DocId dID)

getRecordId :: Entity $moduleName -> T.Text 
getRecordId rec = T.pack $$ show $$ fromSqlKey $$ entityKey rec

runES :: (MonadReader Config m, MonadIO m) => BH m a -> m a
runES query = do
    bhEnv <- asks esEnv
    runBH bhEnv query
