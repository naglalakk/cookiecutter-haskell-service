{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE OverloadedStrings #-}

module Elasticsearch where

import Control.Monad               (sequence_, unless)
import Control.Monad.Reader        (MonadIO, MonadReader, asks)
import Data.Aeson
import Database.V5.Bloodhound
import GHC.Generics                (Generic)
import Database.Persist.Postgresql (Entity(..), selectList, fromSqlKey)
import Network.HTTP.Client         (responseStatus)
import Network.HTTP.Types          (statusCode)
import qualified Data.Text         as T

import Models                      ($moduleName(..), runDb)
import Config                      (Config, esEnv)

data $moduleNameMapping = $moduleNameMapping deriving (Eq, Show, Generic)

instance FromJSON $moduleNameMapping 
instance ToJSON  $moduleNameMapping

indexSettings :: IndexSettings
indexSettings = defaultIndexSettings

indexName :: IndexName
indexName = IndexName "yourindex"

mappingName :: MappingName
mappingName = MappingName "yourmapping"

makeIndex :: (MonadReader Config m, MonadIO m) => m Reply
makeIndex = runES $ createIndex indexSettings indexName

destroyIndex :: (MonadReader Config m, MonadIO m) => m Reply
destroyIndex = runES $ deleteIndex indexName

makeMapping :: (MonadReader Config m, MonadIO m) => m Reply
makeMapping = runES $ putMapping indexName mappingName $moduleNameMapping 

put$moduleName :: (MonadReader Config m, MonadIO m) => $moduleName -> T.Text -> m Reply
put$moduleName object dID = do
    reply <- get$moduleName dID
    let sCode = statusCode $ responseStatus reply
    case sCode of
      -- update
      200 -> update$moduleName object dID
      -- create
      404 -> runES $ indexDocument indexName mappingName defaultIndexDocumentSettings object $ DocId dID

update$moduleName :: (MonadReader Config m, MonadIO m) => Registration -> T.Text -> m Reply
update$moduleName object dID = runES $ updateDocument indexName mappingName defaultIndexDocumentSettings object $ DocId dID

all$moduleNames :: (MonadReader Config m, MonadIO m) => m [Entity $moduleName]
all$moduleNames = runDb $ selectList []Â []

syncDb$moduleNames :: (MonadReader Config m, MonadIO m) => m [Reply]
syncDb$moduleNames = do
    exists <- runES $ indexExists indexName
    unless exists $ sequence_ [makeIndex, makeMapping]
    objects <- all$moduleNames
    mapped <- mapM (\x -> put$moduleName (entityVal x) (getRegId x)) objects
    return mapped

get$moduleName :: (MonadReader Config m, MonadIO m) => T.Text -> m Reply
get$moduleName dID = runES $ getDocument indexName mappingName (DocId dID)

getRecordId :: Entity $moduleName -> T.Text 
getRecordId rec = T.pack $ show $ fromSqlKey $ entityKey rec

runES :: (MonadReader Config m, MonadIO m) => BH m a -> m a
runES query = do
    bhEnv <- asks esEnv
    runBH bhEnv query
